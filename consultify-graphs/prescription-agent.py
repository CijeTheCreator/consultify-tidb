import os
from pydantic import BaseModel, Field
from typing import List, Dict, Any
from langgraph.graph import MessagesState
from langgraph.graph import StateGraph, START, END
from langgraph.prebuilt import ToolNode
from langgraph.prebuilt import tools_condition
from pydantic import BaseModel, Field
from typing import Literal
from langchain.chat_models import init_chat_model
from langchain_mistralai import ChatMistralAI
from langchain_community.vectorstores import TiDBVectorStore
from langchain_mistralai import MistralAIEmbeddings
from dotenv import load_dotenv
from langchain.tools.retriever import create_retriever_tool
from langgraph.graph import StateGraph, START, END
load_dotenv()


class GraphState(BaseModel):
    """This will serve as the state for the graph"""
    conversation: dict = Field(
        description="This is the message thread so far"
    )
    last_inserted_message: dict = Field(
        description="This is the last inserted message by a user"
    )
    query: dict = Field(
        description="Query generated by the query generation node"
    )
    refined_query: dict = Field(
        description="Query generated by the rewrite query node"
    )
    context_retrieved: str = Field(
        description="Context retrieved from the vector store"
    )
    consultation: str = Field(
        description="Metadata of the active consultation"
    )

# Initialize the same embedding model you used before
embeddings = MistralAIEmbeddings()

# Connect to existing vector store
tidb_connection_string = os.getenv("TIDB_CONN_STRING") or ""
vector_store = TiDBVectorStore(
    connection_string=tidb_connection_string,
    embedding_function=embeddings,
    table_name="british-formulary",  # Your existing table name
    distance_strategy="cosine"
)

# Create retriever
retriever = vector_store.as_retriever(
    search_type="similarity",
    search_kwargs={"k": 5}  # Number of documents to retrieve
)

retriever_tool = create_retriever_tool(
    retriever,
    "retrieve_info_on_drugs",
    "Search and return information about drugs",
)

response_model = ChatMistralAI()

def create_prescription_lookup_query(state: MessagesState):
    """Call the model to generate a response based on the current state. Given
    the question, it will decide to retrieve using the retriever tool, or simply respond to the user.
    """
    response = (
        response_model
        .bind_tools([retriever_tool]).invoke(state["messages"])
    )
    return {"messages": [response]}

GRADE_PROMPT = (
    "You are a grader assessing relevance of a retrieved document to a user question. \n "
    "Here is the retrieved document: \n\n {context} \n\n"
    "Here is the user question: {question} \n"
    "If the document contains keyword(s) or semantic meaning related to the user question, grade it as relevant. \n"
    "Give a binary score 'yes' or 'no' score to indicate whether the document is relevant to the question."
)


class GradeDocuments(BaseModel):
    """Grade documents using a binary score for relevance check."""
    binary_score: str = Field(
        description="Relevance score: 'yes' if relevant, or 'no' if not relevant"
    )

grader_model = ChatMistralAI()

def grade_documents(
    state: MessagesState,
) -> Literal["generate_response", "refine_search_query"]:
    """Determine whether the retrieved documents are relevant to the question."""
    question = state["messages"][0].content
    context = state["messages"][-1].content

    prompt = GRADE_PROMPT.format(question=question, context=context)
    response = (
        grader_model
        .with_structured_output(GradeDocuments).invoke(
            [{"role": "user", "content": prompt}]
        )
    )
    score = response.binary_score
    if score == "yes":
        return "generate_response"
    else:
        return "refine_search_query"

class RewrittenQuestion(BaseModel):
    """Pydantic model for the rewritten question response."""
    improved_question: str = Field(
        description="The semantically improved and clarified version of the original question"
    )

REWRITE_PROMPT = (
    "Look at the input and try to reason about the underlying semantic intent / meaning.\n"
    "Here is the initial question:"
    "\n ------- \n"
    "{question}"
    "\n ------- \n"
    "Formulate an improved question that captures the core intent more clearly and precisely."
)

def refine_search_query(state: MessagesState):
    """Rewrite the original user question using structured output."""
    messages = state["messages"]
    question = messages[0]["content"]
    prompt = REWRITE_PROMPT.format(question=question)
    # Configure the model to use structured output with Pydantic
    # This assumes you're using a model that supports structured output like OpenAI's GPT models
    response = response_model.with_structured_output(RewrittenQuestion).invoke([
        {"role": "user", "content": prompt}
    ])
    # Extract just the improved question string
    improved_question = response.improved_question
    return {"messages": [{"role": "user", "content": improved_question}]}

GENERATE_PROMPT = (
    "You are an assistant for question-answering tasks. "
    "Use the following pieces of retrieved context to answer the question. "
    "If you don't know the answer, just say that you don't know. "
    "Use three sentences maximum and keep the answer concise.\n"
    "Question: {question} \n"
    "Context: {context}"
)

def generate_response(state: MessagesState):
    """Generate an answer."""
    question = state["messages"][0].content
    context = state["messages"][-1].content
    prompt = GENERATE_PROMPT.format(question=question, context=context)
    response = response_model.invoke([{"role": "user", "content": prompt}])
    return {"messages": [response]}

workflow = StateGraph(MessagesState)


workflow.add_node(create_prescription_lookup_query)
workflow.add_node("search_british_national_formulary", ToolNode([retriever_tool]))
workflow.add_node(refine_search_query)
workflow.add_node(generate_response)
workflow.add_edge(
    START,
    "create_prescription_lookup_query"
)
# Decide whether to retrieve
workflow.add_conditional_edges(
    "create_prescription_lookup_query",
    # Assess LLM decision (call `retriever_tool` tool or respond to the user)
    tools_condition,
    {
        # Translate the condition outputs to nodes in our graph
        "tools": "search_british_national_formulary",
        END: END,
    },
)
# Edges taken after the `action` node is called.
workflow.add_conditional_edges(
    "search_british_national_formulary",
    # Assess agent decision
    grade_documents,
)
workflow.add_edge("generate_response", END)
workflow.add_edge("refine_search_query", "create_prescription_lookup_query")

# Compile
graph = workflow.compile()
